
#include <algorithm>

#include "altypes.hpp"
#include "tsmefilter.hpp"

namespace {

template<usize A, typename T, usize N>
constexpr auto assume_aligned_span(std::span<T,N> const s) noexcept -> std::span<T,N>
{ return std::span<T,N>{std::assume_aligned<A>(s.data()), s.size()}; }

} /* namespace */


/* Encoding Tetraphonic Surround from ACN/N3D B-Format is done as:
 *
 * Fl = 0.353553390592*W +  0.288623887591*Y +  0.204196677392*X
 * Fr = 0.353553390592*W + -0.288623887591*Y +  0.204196677392*X
 * Bu = 0.353553390592*W +  0.288623887591*Z + -0.204196677392*X
 * Bd = 0.353553390592*W + -0.288623887591*Z + -0.204196677392*X
 *
 * Flt = 0.985144642804*Fl - 0.169433780045*Fr
 * Frt = 0.985144642804*Fr - 0.169433780045*Fl
 *
 * Blt = -0.459812358448*Bu + j(0.888016100653*Bu) + 0.459812358448*Bd + j(0.888016100653*Bd)
 * Brt = -0.459812358448*Bd + j(0.888016100653*Bd) + 0.459812358448*Bu + j(0.888016100653*Bu)
 *
 * Left  = Flt + 0.707106781187*Blt
 * Right = Frt - 0.707106781187*Brt
 *
 * where j is a wide-band +90 degree phase shift. Breaking this down, we can
 * calculate Flt, Frt, Blt, and Brt directly:
 *
 * Flt = 0.985144642804*(0.353553390592*W +  0.288623887591*Y +  0.204196677392*X) - 0.169433780045*(0.353553390592*W + -0.288623887591*Y +  0.204196677392*X)
 *     = 0.985144642804*(0.353553390592*W +  0.288623887591*Y +  0.204196677392*X) + -0.169433780045*(0.353553390592*W + -0.288623887591*Y +  0.204196677392*X)
 *     = 0.985144642804*0.353553390592*W +  0.985144642804*0.288623887591*Y +  0.985144642804*0.204196677392*X + -0.169433780045*0.353553390592*W + -0.169433780045*-0.288623887591*Y +  -0.169433780045*0.204196677392*X
 *     = (0.985144642804*0.353553390592 + -0.169433780045*0.353553390592)*W +  (0.985144642804*0.288623887591 + -0.169433780045*-0.288623887591)*Y +  (0.985144642804*0.204196677392 +  -0.169433780045*0.204196677392)*X
 *     = 0.288397341271*W + 0.333238912931*Y + 0.166565447888*X
 *
 * Frt = 0.985144642804*(0.353553390592*W + -0.288623887591*Y +  0.204196677392*X) - 0.169433780045*(0.353553390592*W +  0.288623887591*Y +  0.204196677392*X)
 *     = 0.985144642804*(0.353553390592*W + -0.288623887591*Y +  0.204196677392*X) + -0.169433780045*(0.353553390592*W +  0.288623887591*Y +  0.204196677392*X)
 *     = 0.985144642804*0.353553390592*W + 0.985144642804*-0.288623887591*Y +  0.985144642804*0.204196677392*X + -0.169433780045*0.353553390592*W +  -0.169433780045*0.288623887591*Y +  -0.169433780045*0.204196677392*X
 *     = 0.985144642804*0.353553390592*W + -0.169433780045*0.353553390592*W + 0.985144642804*-0.288623887591*Y +  -0.169433780045*0.288623887591*Y +  0.985144642804*0.204196677392*X +  -0.169433780045*0.204196677392*X
 *     = (0.985144642804*0.353553390592 + -0.169433780045*0.353553390592)*W + (0.985144642804*-0.288623887591 +  -0.169433780045*0.288623887591)*Y +  (0.985144642804*0.204196677392 +  -0.169433780045*0.204196677392)*X
 *     = 0.288397341271*W + -0.333238912931*Y + 0.166565447888*X
 *
 * Blt = -0.459812358448*(0.353553390592*W +  0.288623887591*Z + -0.204196677392*X) + j(0.888016100653*(0.353553390592*W +  0.288623887591*Z + -0.204196677392*X)) + 0.459812358448*(0.353553390592*W + -0.288623887591*Z + -0.204196677392*X) + j(0.888016100653*(0.353553390592*W + -0.288623887591*Z + -0.204196677392*X))
 *     = -0.459812358448*(0.353553390592*W +  0.288623887591*Z + -0.204196677392*X) + 0.459812358448*(0.353553390592*W + -0.288623887591*Z + -0.204196677392*X)
 *       + j(0.888016100653*(0.353553390592*W +  0.288623887591*Z + -0.204196677392*X) + 0.888016100653*(0.353553390592*W + -0.288623887591*Z + -0.204196677392*X))
 *     = -0.459812358448*0.353553390592*W +  -0.459812358448*0.288623887591*Z + -0.459812358448*-0.204196677392*X + 0.459812358448*0.353553390592*W + 0.459812358448*-0.288623887591*Z + 0.459812358448*-0.204196677392*X
 *       + j(0.888016100653*0.353553390592*W +  0.888016100653*0.288623887591*Z + 0.888016100653*-0.204196677392*X + 0.888016100653*0.353553390592*W + 0.888016100653*-0.288623887591*Z + 0.888016100653*-0.204196677392*X)
 *     = -0.459812358448*0.353553390592*W + 0.459812358448*0.25*W +  -0.459812358448*0.288623887591*Z + 0.459812358448*-0.288623887591*Z + -0.459812358448*-0.204196677392*X + 0.459812358448*-0.204196677392*X
 *       + j(0.888016100653*0.353553390592*W + 0.888016100653*0.353553390592*W +  0.888016100653*0.288623887591*Z + 0.888016100653*-0.288623887591*Z + 0.888016100653*-0.204196677392*X + 0.888016100653*-0.204196677392*X)
 *     = (-0.459812358448*0.353553390592 + 0.459812358448*0.353553390592)*W +  (-0.459812358448*0.288623887591 + 0.459812358448*-0.288623887591)*Z + (-0.459812358448*-0.204196677392 + 0.459812358448*-0.204196677392)*X
 *       + j((0.888016100653*0.353553390592 + 0.888016100653*0.353553390592)*W +  (0.888016100653*0.288623887591 + 0.888016100653*-0.288623887591)*Z + (0.888016100653*-0.204196677392 + 0.888016100653*-0.204196677392)*X)
 *     = -0.265425660915*Z + j(0.627922206572*W + -0.362659874448*X)
 *
 * Brt = -0.459812358448*(0.353553390592*W + -0.288623887591*Z + -0.204196677392*X) + j(0.888016100653*(0.353553390592*W + -0.288623887591*Z + -0.204196677392*X)) + 0.459812358448*(0.353553390592*W +  0.288623887591*Z + -0.204196677392*X) + j(0.888016100653*(0.353553390592*W +  0.288623887591*Z + -0.204196677392*X))
 *     = -0.459812358448*(0.353553390592*W + -0.288623887591*Z + -0.204196677392*X) + 0.459812358448*(0.353553390592*W +  0.288623887591*Z + -0.204196677392*X)
 *       + j(0.888016100653*(0.353553390592*W + -0.288623887591*Z + -0.204196677392*X) + 0.888016100653*(0.353553390592*W +  0.288623887591*Z + -0.204196677392*X))
 *     = -0.459812358448*0.353553390592*W + -0.459812358448*-0.288623887591*Z + -0.459812358448*-0.204196677392*X + 0.459812358448*0.353553390592*W +  0.459812358448*0.288623887591*Z + 0.459812358448*-0.204196677392*X
 *       + j(0.888016100653*0.353553390592*W + 0.888016100653*-0.288623887591*Z + 0.888016100653*-0.204196677392*X + 0.888016100653*0.353553390592*W +  0.888016100653*0.288623887591*Z + 0.888016100653*-0.204196677392*X)
 *     = -0.459812358448*0.353553390592*W + 0.459812358448*0.353553390592*W + -0.459812358448*-0.288623887591*Z +  0.459812358448*0.288623887591*Z + -0.459812358448*-0.204196677392*X + 0.459812358448*-0.204196677392*X
 *       + j(0.888016100653*0.353553390592*W + 0.888016100653*0.353553390592*W + 0.888016100653*-0.288623887591*Z +  0.888016100653*0.288623887591*Z + 0.888016100653*-0.204196677392*X + 0.888016100653*-0.204196677392*X)
 *     = (-0.459812358448*0.353553390592 + 0.459812358448*0.353553390592)*W + (-0.459812358448*-0.288623887591 +  0.459812358448*0.288623887591)*Z + (-0.459812358448*-0.204196677392 + 0.459812358448*-0.204196677392)*X
 *       + j((0.888016100653*0.353553390592 + 0.888016100653*0.353553390592)*W + (0.888016100653*-0.288623887591 +  0.888016100653*0.288623887591)*Z + (0.888016100653*-0.204196677392 + 0.888016100653*-0.204196677392)*X)
 *     = 0.265425660915*Z + j(0.627922206572*W + -0.362659874448*X)
 *
 * We can further break down the Left and Right results using the new inputs:
 *
 * Left  = Flt + 0.707106781187*Blt
 *       = 0.288397341271*W + 0.333238912931*Y + 0.166565447888*X +  0.707106781187*(-0.265425660915*Z + j(0.627922206572*W + -0.362659874448*X))
 *       = 0.288397341271*W + 0.333238912931*Y + 0.166565447888*X +  0.707106781187*-0.265425660915*Z + j(0.707106781187*0.627922206572*W + 0.707106781187*-0.362659874448*X)
 *       = 0.288397341271*W + 0.333238912931*Y + 0.166565447888*X + -0.187684284734*Z + j(0.313961103288*W + -0.256439256487*X)
 *
 * Right = Frt + -0.707106781187*Brt
 *       = 0.288397341271*W + -0.333238912931*Y + 0.166565447888*X + -0.707106781187*( 0.265425660915*Z + j(0.627922206572*W + -0.362659874448*X))
 *       = 0.288397341271*W + -0.333238912931*Y + 0.166565447888*X + -0.707106781187*0.265425660915*Z + j(-0.707106781187*0.627922206572*W + -0.707106781187*-0.362659874448*X)
 *       = 0.288397341271*W + -0.333238912931*Y + 0.166565447888*X + -0.187684284734*Z + j(-0.444008050325*W + 0.256439256487*X)
 *
 * To simplify this more, we can take the Sum and Difference signals:
 *
 * S = Left/2 + Right/2
 *   = (0.288397341271*W + 0.333238912931*Y + 0.166565447888*X + -0.187684284734*Z + j(0.444008050325*W + -0.256439256487*X))/2
 *     + (0.288397341271*W + -0.333238912931*Y + 0.166565447888*X + -0.187684284734*Z + j(-0.444008050325*W + 0.256439256487*X))/2
 *   = (0.288397341271*W + 0.166565447888*X + -0.187684284734*Z)/2
 *     + (0.288397341271*W + 0.166565447888*X + -0.187684284734*Z)/2
 *   = 0.288397341271*W + 0.166565447888*X + -0.187684284734*Z
 * D = Left/2 - Right/2
 *   = (0.288397341271*W + 0.333238912931*Y + 0.166565447888*X + -0.187684284734*Z + j(0.444008050325*W + -0.256439256487*X))/2
 *     - (0.288397341271*W + -0.333238912931*Y + 0.166565447888*X + -0.187684284734*Z + j(-0.444008050325*W + 0.256439256487*X))/2
 *   = (0.288397341271*W + 0.333238912931*Y + 0.166565447888*X + -0.187684284734*Z + j(0.444008050325*W + -0.256439256487*X))/2
 *     + (-0.288397341271*W + 0.333238912931*Y + -0.166565447888*X + 0.187684284734*Z + j(0.444008050325*W + -0.256439256487*X))/2
 *   = (0.333238912931*Y + j(0.444008050325*W + -0.256439256487*X))/2
 *     + (0.333238912931*Y + j(0.444008050325*W + -0.256439256487*X))/2
 *   = 0.333238912931*Y + j(0.444008050325*W + -0.256439256487*X)
 *
 * So finally, we get:
 *
 * S = 0.288397341271*W + 0.166565447888*X - 0.187684284734*Z
 * D = j(0.444008050325*W - 0.256439256487*X) + 0.333238912931*Y
 *
 * Left  = S + D
 * Right = S - D
 */

/* This encoding implementation uses two sets of four chained IIR filters to
 * produce the desired relative phase shift. See uhjfilter.cpp for more
 * details.
 */
void TsmeEncoderIIR::encode(std::span<float> LeftOut, std::span<float> RightOut,
     std::span<const std::span<const float>> InSamples)
{
    const auto samplesToDo = InSamples[0].size();
    const auto winput = assume_aligned_span<16>(InSamples[0]);
    const auto yinput = assume_aligned_span<16>(InSamples[1].first(samplesToDo));
    const auto zinput = assume_aligned_span<16>(InSamples[2].first(samplesToDo));
    const auto xinput = assume_aligned_span<16>(InSamples[3].first(samplesToDo));

    /* S = 0.288397341271*W + 0.166565447888*X - 0.187684284734*Z */
    std::ranges::transform(winput, xinput, mTemp.begin(),
        [](const float w, const float x) { return 0.288397341271f*w + 0.166565447888f*x; });
    std::ranges::transform(mTemp, zinput, mTemp.begin(),
        [](const float wx, const float z) { return wx - 0.187684284734f*z; });
    process(mFilter1WXZ, Filter1Coeff, std::span{mTemp}.first(samplesToDo), true,
        std::span{mS}.subspan(1));
    mS[0] = mDelayWXZ; mDelayWXZ = mS[samplesToDo];

    /* Precompute j(0.444008050325*W - 0.256439256487*X) and store in mWX. */
    std::ranges::transform(winput, xinput, mTemp.begin(),
        [](const float w, const float x) { return 0.444008050325f*w - 0.256439256487f*x; });
    process(mFilter2WX, Filter2Coeff, std::span{mTemp}.first(samplesToDo), true, mWX);

    /* Apply filter1 to Y and store in mD. */
    process(mFilter1Y, Filter1Coeff, yinput, true, std::span{mD}.subspan(1));
    mD[0] = mDelayY; mDelayY = mD[samplesToDo];

    /* D = j(0.444008050325*W - 0.256439256487*X) + 0.333238912931*Y */
    std::ranges::transform(mWX | std::views::take(samplesToDo), mD, mD.begin(),
        [](const float jwx, const float y) noexcept { return jwx + 0.333238912931f*y; });

    /* Apply the base filter to the existing output to align with the processed
     * signal.
     */
    const auto left = assume_aligned_span<16>(LeftOut.first(samplesToDo));
    process(mFilter1Direct[0], Filter1Coeff, left, true, std::span{mTemp}.subspan(1));
    mTemp[0] = mDirectDelay[0]; mDirectDelay[0] = mTemp[samplesToDo];

    /* Left = S + D */
    for(auto i = 0_uz;i < samplesToDo;++i)
        left[i] = mS[i] + mD[i] + mTemp[i];

    const auto right = assume_aligned_span<16>(RightOut.first(samplesToDo));
    process(mFilter1Direct[1], Filter1Coeff, right, true, std::span{mTemp}.subspan(1));
    mTemp[0] = mDirectDelay[1]; mDirectDelay[1] = mTemp[samplesToDo];

    /* Right = S - D */
    for(auto i = 0_uz;i < samplesToDo;++i)
        right[i] = mS[i] - mD[i] + mTemp[i];
}
